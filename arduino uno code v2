#include <Servo.h>

// --- Configuration ---
const int servoPins[6] = {3, 5, 6, 9, 10, 11}; // Ensure these are PWM pins
Servo servos[6];

// Positions
const int UP_POS = 90;   // Angle for dot raised
const int DOWN_POS = 0;  // Angle for dot lowered
const int MOVE_DELAY = 300; // Time for mechanical movement (ms)

// Globals for Serial Parsing
const byte numChars = 32;
char receivedChars[numChars];
boolean newData = false;

// --- Braille Mapping Setup ---
// We map ASCII characters to 6-bit binary patterns representing dots 1-6.
// 1 = UP, 0 = DOWN. Pattern order: [Pin1, Pin2, Pin3, Pin4, Pin5, Pin6]
// Standard Braille numbering:
// 1  4
// 2  5
// 3  6
byte brailleMap[26][6] = {
  {1,0,0,0,0,0}, // a (dot 1)
  {1,1,0,0,0,0}, // b (dots 1,2)
  {1,0,0,1,0,0}, // c (dots 1,4)
  {1,0,0,1,1,0}, // d (dots 1,4,5)
  {1,0,0,0,1,0}, // e (dots 1,5)
  {1,1,0,1,0,0}, // f (dots 1,2,4)
  {1,1,0,1,1,0}, // g (dots 1,2,4,5)
  {1,1,0,0,1,0}, // h (dots 1,2,5)
  {0,1,0,1,0,0}, // i (dots 2,4)
  {0,1,0,1,1,0}, // j (dots 2,4,5)
  {1,0,1,0,0,0}, // k (dots 1,3)
  {1,1,1,0,0,0}, // l (dots 1,2,3)
  {1,0,1,1,0,0}, // m (dots 1,3,4)
  {1,0,1,1,1,0}, // n (dots 1,3,4,5)
  {1,0,1,0,1,0}, // o (dots 1,3,5)
  {1,1,1,1,0,0}, // p (dots 1,2,3,4)
  {1,1,1,1,1,0}, // q (dots 1,2,3,4,5)
  {1,1,1,0,1,0}, // r (dots 1,2,3,5)
  {0,1,1,1,0,0}, // s (dots 2,3,4)
  {0,1,1,1,1,0}, // t (dots 2,3,4,5)
  {1,0,1,0,0,1}, // u (dots 1,3,6)
  {1,1,1,0,0,1}, // v (dots 1,2,3,6)
  {0,1,0,1,1,1}, // w (special case - dots 2,4,5,6)
  {1,0,1,1,0,1}, // x (dots 1,3,4,6)
  {1,0,1,1,1,1}, // y (dots 1,3,4,5,6)
  {1,0,1,0,1,1}  // z (dots 1,3,5,6)
};

void setup() {
  Serial.begin(115200); // High speed serial
  Serial.println("<ARDUINO_STARTING>"); // Signal to Python we booted

  // Attach servos and initialize to DOWN position
  for (int i = 0; i < 6; i++) {
    servos[i].attach(servoPins[i]);
    servos[i].write(DOWN_POS);
  }
  delay(500);
  Serial.println("<READY>"); // Final handshake signal
}

void loop() {
  recvWithStartEndMarkers();
  if (newData == true) {
    processCommand();
    newData = false;
  }
}

// --- Helper Functions ---

// Robust function to read data between < and > markers
void recvWithStartEndMarkers() {
  static boolean recvInProgress = false;
  static byte ndx = 0;
  char startMarker = '<';
  char endMarker = '>';
  char rc;

  while (Serial.available() > 0 && newData == false) {
    rc = Serial.read();

    if (recvInProgress == true) {
      if (rc != endMarker) {
        receivedChars[ndx] = rc;
        ndx++;
        if (ndx >= numChars) { ndx = numChars - 1; }
      } else {
        receivedChars[ndx] = '\0'; // terminate string
        recvInProgress = false;
        ndx = 0;
        newData = true;
      }
    } else if (rc == startMarker) {
      recvInProgress = true;
    }
  }
}

// Decide what to do with the received data
void processCommand() {
  String cmd = String(receivedChars);
  
  if (cmd == "RESET") {
    resetAllServos();
    Serial.println("<ACK_RESET>"); // Handshake back to Python
  } 
  else if (cmd.length() == 1) {
    // It's likely a single character command to render
    char charToRender = cmd.charAt(0);
    renderCharacter(charToRender);
    Serial.println("<ACK_DONE>"); // Handshake back to Python
  }
  // If unknown command, do nothing
}

void resetAllServos() {
  for (int i = 0; i < 6; i++) {
    servos[i].write(DOWN_POS);
  }
  delay(MOVE_DELAY); // Ensure physical time to drop
}

void renderCharacter(char c) {
  // Ensure character is lowercase for mapping index
  c = tolower(c);
  int index = c - 'a';

  // Check if it's a valid letter 'a' through 'z'
  if (index >= 0 && index < 26) {
    for (int i = 0; i < 6; i++) {
      if (brailleMap[index][i] == 1) {
        servos[i].write(UP_POS);
      } else {
        servos[i].write(DOWN_POS);
      }
    }
    delay(MOVE_DELAY); // Wait for servos to physically rise
  } else {
     // Handle non-letters (spaces, punctuation) by resetting pins
     resetAllServos();
  }
}
